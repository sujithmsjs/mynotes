

1. ConfigurationException: Could not locate cfg.xml
2. 	ServiceException
	ClassLoadingException: Unable to load class [com.mysql.cj.jdbc.Driver]
	ClassNotFoundException: Could not load requested class : com.mysql.cj.jdbc.Driver
3. WARN: HHH000342: Could not obtain connection to query metadata

@Entity
@Table(name = "demo1")
public class UserData {

	@Id
	@Column(name = "user_id", length = 5)
	@GeneratedValue
	private int uid;
	
	private String name;
	@Column(name = "username",length = 20,unique = true, nullable = false)
	private String username;
	private String password;
	
	@Temporal(TemporalType.DATE)
	private Calendar dob = new GregorianCalendar(1994,9,2);
	
	@Temporal(TemporalType.TIME)
	@Column(name="birth_time")
	private Date birthtime;

	private double cgpa;
	private float percentage;
	private byte section;
	private int marks;
	
	@Column(name = "has_ncc", nullable = false)
	private boolean hasNCC;
	
	@CreationTimestamp
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "create_date")
	private Calendar createdOn;

	@UpdateTimestamp
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "modify_date")
	private Date modifyDate;
}

mysql> desc demo1;
+-------------+--------------+------+-----+
| Field       | Type         | Null | Key |
+-------------+--------------+------+-----+
| user_id     | int          | NO   | PRI |
| birth_time  | time         | YES  |     |
| cgpa        | double       | NO   |     |
| create_date | datetime(6)  | YES  |     |
| dob         | date         | YES  |     |
| has_ncc     | bit(1)       | NO   |     |
| marks       | int          | NO   |     |
| modify_date | datetime(6)  | YES  |     |
| name        | varchar(255) | YES  |     |
| password    | varchar(255) | YES  |     |
| percentage  | float        | NO   |     |
| section     | tinyint      | NO   |     |
| username    | varchar(20)  | NO   | UNI |
+-------------+--------------+------+-----+

We you to take care about the Default and Autogenerated values from Java side.
+-------------------+-------------------+
| Default           | Extra             |
+-------------------+-------------------+


The main function of the Session is to offer create, read and delete operations for instances of mapped entity classes. Instances may exist in one of three states:

transient: never persistent, not associated with any Session
persistent: associated with a unique Session
detached: previously persistent, not associated with any Session

Transient instances may be made persistent by calling save(), persist() or saveOrUpdate().
Persistent instances may be made transient by calling delete().
Any instance returned by a get() or load() method is persistent.
Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate().

save(),persist() --->SQL INSERT
delete() ---> SQL DELETE
update(), merge() ---> UPDATE.
saveOrUpdate() and replicate() --> INSERT or UPDATE.
Changes to persistent instances are detected at flush time and also result in an SQL UPDATE. 

identical 
GregorianCalendar

https://docs.jboss.org/hibernate/orm/5.6/quickstart/html_single/#hibernate-gsg-tutorial-basic-test
https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/Session.html

javax.persistence.EntityManager
Query	createNamedQuery(String name)
boolean	contains(Object entity)
Query	createNativeQuery(String sqlString)
StoredProcedureQuery	createStoredProcedureQuery(String procedureName)
void	detach(Object entity)
void	flush()
boolean	isOpen()
<T> T	merge(T entity)	
void	persist(Object entity)
void	refresh(Object entity)
void	remove(Object entity)

try {
    session.save(user2);
} catch (Exception e) {
	System.out.println(e.getMessage());
}
A different object with the same identifier value was already associated with the session : [com.suji.model.UserData#0]


void	reconnect(java.sql.Connection connection)
<T> T	get(Class<T> entityType, Serializable id)
<T> T	load(Class<T> theClass, Serializable id)
void	replicate(Object object, ReplicationMode replicationMode)
boolean	isDirty()
Serializable	save(java.lang.Object object)
void	saveOrUpdate(java.lang.Object object)
void	setFlushMode(FlushMode flushMode)
void	update(java.lang.Object object)
void	setDefaultReadOnly(boolean readOnly)
void	delete(Object object)


@Column(insertable = false)
===========================
Not able to insert data into table.

saveOrUpdate
------------
If(isExists){
	update(entity);
}else{
	save(entity);
}

save(entity)
============
If(isExists){
	NonUniqueObjectException
}else{
	save(entity);
}


QuerySyntaxException
--------------------

DATA_EXCEPTION:
Suppose you set name must not contain more then 20 character, and if it exceed while insertin this DataException will be thrown.
MysqlDataTruncation: Data truncation: Data too long for column 'password' at row 1

NON_UNIQUE_OBJECT_EXCEPTION:
org.hibernate.NonUniqueObjectException
Can catch before commit();

PROPERTY_VALUE_EXCEPTION:
not-null property references a null or transient value

CONSTRAINT_VIOLATION_EXCEPTION:
Must caught at Transaction.commit() method. If we use setter method of an entity, in the end of commit time it will be reflected. After setter method it won't reflected in database but in entity object. for UNIQUE constraint will be raised at commit statement.
It is better to maintain save method at last before commit();

Ex:
user3.setUsername("Sujith");
session.save(user3);

Implementation of JDBCException indicating that the requested DML operation resulted in a violation of a defined integrity constraint.


If 2 enities have same primary key.
org.hibernate.NonUniqueObjectException


Transaction.commit();
Checks the unique session enities and inserts them at once at last.


ConstraintViolationException: Only catchable at Transaction.commit();
